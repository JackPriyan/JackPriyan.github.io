{"ast":null,"code":"var binary = require(\"./binary\");\n\nfunction Node(axis, split, left, right) {\n  this.axis = axis;\n  this.split = split;\n  this.left = left;\n  this.right = right;\n}\n\nfunction distance(a, b) {\n  var i = Math.min(a.length, b.length),\n      d = 0,\n      k;\n\n  while (i--) {\n    k = b[i] - a[i];\n    d += k * k;\n  }\n\n  return d;\n}\n\nfunction byDistance(a, b) {\n  return a.dist - b.dist;\n}\n\nfunction buildrec(array, depth) {\n  /* This should only happen if you request a kd-tree with zero elements. */\n  if (array.length === 0) return null;\n  /* If there's only one item, then it's a leaf node! */\n\n  if (array.length === 1) return array[0];\n  /* Uh oh. Well, we have to partition the data set and recurse. Start by\n   * finding the bounding box of the given points; whichever side is the\n   * longest is the one we'll use for the splitting plane. */\n\n  var axis = depth % array[0].position.length;\n  /* Sort the points along the splitting plane. */\n\n  /* FIXME: For very large trees, it would be faster to use some sort of median\n   * finding and partitioning algorithm. It'd also be a lot more complicated. */\n\n  array.sort(function (a, b) {\n    return a.position[axis] - b.position[axis];\n  });\n  /* Find the median point. It's position is going to be the location of the\n   * splitting plane. */\n\n  var i = Math.floor(array.length * 0.5);\n  /* Split, recurse, yadda yadda. */\n\n  ++depth;\n  return new Node(axis, array[i].position[axis], buildrec(array.slice(0, i), depth), buildrec(array.slice(i), depth));\n}\n\nfunction build(array) {\n  return buildrec(array, 0);\n}\n\nfunction lookup(position, node, n, max) {\n  if (!(max > 0)) max = Number.POSITIVE_INFINITY;\n  var array = [];\n  /* Degenerate cases. */\n\n  if (node === null || n <= 0) return array;\n  var stack = [node, 0],\n      dist,\n      i;\n\n  while (stack.length) {\n    dist = stack.pop();\n    node = stack.pop();\n    /* If this subtree is further away than we care about, then skip it. */\n\n    if (dist > max) continue;\n    /* If we've already found enough locations, and the furthest one is closer\n     * than this subtree possibly could be, just skip the subtree. */\n\n    if (array.length === n && array[array.length - 1].dist < dist * dist) continue;\n    /* Iterate all the way down the tree, adding nodes that we need to remember\n     * to visit later onto the stack. */\n\n    while (node instanceof Node) {\n      if (position[node.axis] < node.split) {\n        stack.push(node.right, node.split - position[node.axis]);\n        node = node.left;\n      } else {\n        stack.push(node.left, position[node.axis] - node.split);\n        node = node.right;\n      }\n    }\n    /* Once we've hit a leaf node, insert it into the array of candidates,\n     * making sure to keep the array in sorted order. */\n\n\n    dist = distance(position, node.position);\n    if (dist <= max * max) binary.insert({\n      object: node,\n      dist: dist\n    }, array, byDistance);\n    /* If the array's too long, cull it. */\n\n    if (array.length > n) array.pop();\n  }\n  /* Strip candidate wrapper objects. */\n\n\n  i = array.length;\n\n  while (i--) array[i] = array[i].object;\n\n  return array;\n}\n\nexports.build = build;\nexports.lookup = lookup;","map":{"version":3,"sources":["C:/Users/Jakith/JackPriyan.github.io/node_modules/sphere-knn/lib/kd.js"],"names":["binary","require","Node","axis","split","left","right","distance","a","b","i","Math","min","length","d","k","byDistance","dist","buildrec","array","depth","position","sort","floor","slice","build","lookup","node","n","max","Number","POSITIVE_INFINITY","stack","pop","push","insert","object","exports"],"mappings":"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","sourcesContent":["var binary = require(\"./binary\")\n\nfunction Node(axis, split, left, right) {\n  this.axis  = axis\n  this.split = split\n  this.left  = left\n  this.right = right\n}\n\nfunction distance(a, b) {\n  var i = Math.min(a.length, b.length),\n      d = 0,\n      k\n\n  while(i--) {\n    k  = b[i] - a[i]\n    d += k * k\n  }\n\n  return d\n}\n\nfunction byDistance(a, b) {\n  return a.dist - b.dist\n}\n\nfunction buildrec(array, depth) {\n  /* This should only happen if you request a kd-tree with zero elements. */\n  if(array.length === 0)\n    return null\n\n  /* If there's only one item, then it's a leaf node! */\n  if(array.length === 1)\n    return array[0]\n\n  /* Uh oh. Well, we have to partition the data set and recurse. Start by\n   * finding the bounding box of the given points; whichever side is the\n   * longest is the one we'll use for the splitting plane. */\n  var axis = depth % array[0].position.length\n\n  /* Sort the points along the splitting plane. */\n  /* FIXME: For very large trees, it would be faster to use some sort of median\n   * finding and partitioning algorithm. It'd also be a lot more complicated. */\n  array.sort(function(a, b) {\n    return a.position[axis] - b.position[axis]\n  })\n\n  /* Find the median point. It's position is going to be the location of the\n   * splitting plane. */\n  var i = Math.floor(array.length * 0.5)\n\n  /* Split, recurse, yadda yadda. */\n  ++depth\n\n  return new Node(\n    axis,\n    array[i].position[axis],\n    buildrec(array.slice(0, i), depth),\n    buildrec(array.slice(i   ), depth)\n  )\n}\n\nfunction build(array) {\n  return buildrec(array, 0)\n}\n\nfunction lookup(position, node, n, max) {\n  if(!(max > 0))\n    max = Number.POSITIVE_INFINITY\n\n  var array = []\n\n  /* Degenerate cases. */\n  if(node === null || n <= 0)\n    return array\n\n  var stack = [node, 0],\n      dist, i\n\n  while(stack.length) {\n    dist = stack.pop()\n    node = stack.pop()\n\n    /* If this subtree is further away than we care about, then skip it. */\n    if(dist > max)\n      continue\n\n    /* If we've already found enough locations, and the furthest one is closer\n     * than this subtree possibly could be, just skip the subtree. */\n    if(array.length === n && array[array.length - 1].dist < dist * dist)\n      continue\n\n    /* Iterate all the way down the tree, adding nodes that we need to remember\n     * to visit later onto the stack. */\n    while(node instanceof Node) {\n      if(position[node.axis] < node.split) {\n        stack.push(node.right, node.split - position[node.axis])\n        node = node.left\n      }\n\n      else {\n        stack.push(node.left, position[node.axis] - node.split)\n        node = node.right\n      }\n    }\n\n    /* Once we've hit a leaf node, insert it into the array of candidates,\n     * making sure to keep the array in sorted order. */\n    dist = distance(position, node.position)\n    if(dist <= max * max)\n      binary.insert({object: node, dist: dist}, array, byDistance)\n\n    /* If the array's too long, cull it. */\n    if(array.length > n)\n      array.pop()\n  }\n\n  /* Strip candidate wrapper objects. */\n  i = array.length\n\n  while(i--)\n    array[i] = array[i].object\n\n  return array\n}\n\nexports.build  = build\nexports.lookup = lookup\n"]},"metadata":{},"sourceType":"script"}