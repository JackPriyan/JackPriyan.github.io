{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\Jakith\\\\JackPriyan.github.io\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\Jakith\\\\JackPriyan.github.io\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Jakith\\\\JackPriyan.github.io\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\Jakith\\\\JackPriyan.github.io\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { useCallback, useContext, useEffect, useLayoutEffect, useState, useRef, useMemo } from 'react';\nimport defaultConfig, { CACHE_REVALIDATORS, CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, MUTATION_TS, cache } from './config';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport throttle from './libs/throttle';\nimport SWRConfigContext from './swr-config-context';\nvar IS_SERVER = typeof window === 'undefined'; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\nvar useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n\nvar trigger = function trigger(_key) {\n  var shouldRevalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  // we are ignoring the second argument which correspond to the arguments\n  // the fetcher will receive when key is an array\n  var _cache$serializeKey = cache.serializeKey(_key),\n      _cache$serializeKey2 = _slicedToArray(_cache$serializeKey, 3),\n      key = _cache$serializeKey2[0],\n      keyErr = _cache$serializeKey2[2];\n\n  if (!key) return;\n  var updaters = CACHE_REVALIDATORS[key];\n\n  if (key && updaters) {\n    var currentData = cache.get(key);\n    var currentError = cache.get(keyErr);\n\n    for (var i = 0; i < updaters.length; ++i) {\n      updaters[i](shouldRevalidate, currentData, currentError, i > 0);\n    }\n  }\n};\n\nvar broadcastState = function broadcastState(key, data, error) {\n  var updaters = CACHE_REVALIDATORS[key];\n\n  if (key && updaters) {\n    for (var i = 0; i < updaters.length; ++i) {\n      updaters[i](false, data, error);\n    }\n  }\n};\n\nvar mutate = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_key, _data) {\n    var shouldRevalidate,\n        _cache$serializeKey3,\n        _cache$serializeKey4,\n        key,\n        data,\n        error,\n        updaters,\n        i,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            shouldRevalidate = _args.length > 2 && _args[2] !== undefined ? _args[2] : true;\n            _cache$serializeKey3 = cache.serializeKey(_key), _cache$serializeKey4 = _slicedToArray(_cache$serializeKey3, 1), key = _cache$serializeKey4[0];\n\n            if (key) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 4:\n            if (!(typeof _data === 'undefined')) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", trigger(_key, shouldRevalidate));\n\n          case 6:\n            // update timestamp\n            MUTATION_TS[key] = Date.now() - 1;\n\n            if (!(_data && typeof _data === 'function')) {\n              _context.next = 19;\n              break;\n            }\n\n            _context.prev = 8;\n            _context.next = 11;\n            return _data(cache.get(key));\n\n          case 11:\n            data = _context.sent;\n            _context.next = 17;\n            break;\n\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](8);\n            error = _context.t0;\n\n          case 17:\n            _context.next = 32;\n            break;\n\n          case 19:\n            if (!(_data && typeof _data.then === 'function')) {\n              _context.next = 31;\n              break;\n            }\n\n            _context.prev = 20;\n            _context.next = 23;\n            return _data;\n\n          case 23:\n            data = _context.sent;\n            _context.next = 29;\n            break;\n\n          case 26:\n            _context.prev = 26;\n            _context.t1 = _context[\"catch\"](20);\n            error = _context.t1;\n\n          case 29:\n            _context.next = 32;\n            break;\n\n          case 31:\n            data = _data;\n\n          case 32:\n            if (typeof data !== 'undefined') {\n              // update cached data, avoid notifying from the cache\n              cache.set(key, data, false);\n            } // update existing SWR Hooks' state\n\n\n            updaters = CACHE_REVALIDATORS[key];\n\n            if (updaters) {\n              for (i = 0; i < updaters.length; ++i) {\n                updaters[i](!!shouldRevalidate, data, error, i > 0);\n              }\n            } // throw error or return data to be used by caller of mutate\n\n\n            if (!error) {\n              _context.next = 37;\n              break;\n            }\n\n            throw error;\n\n          case 37:\n            return _context.abrupt(\"return\", data);\n\n          case 38:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[8, 14], [20, 26]]);\n  }));\n\n  return function mutate(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nfunction useSWR() {\n  var _key,\n      fn,\n      config = {};\n\n  if (arguments.length >= 1) {\n    _key = arguments.length <= 0 ? undefined : arguments[0];\n  }\n\n  if (arguments.length > 2) {\n    fn = arguments.length <= 1 ? undefined : arguments[1];\n    config = arguments.length <= 2 ? undefined : arguments[2];\n  } else {\n    if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n      fn = arguments.length <= 1 ? undefined : arguments[1];\n    } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'object') {\n      config = arguments.length <= 1 ? undefined : arguments[1];\n    }\n  } // we assume `key` as the identifier of the request\n  // `key` can change but `fn` shouldn't\n  // (because `revalidate` only depends on `key`)\n  // `keyErr` is the cache key for error objects\n\n\n  var _cache$serializeKey5 = cache.serializeKey(_key),\n      _cache$serializeKey6 = _slicedToArray(_cache$serializeKey5, 3),\n      key = _cache$serializeKey6[0],\n      fnArgs = _cache$serializeKey6[1],\n      keyErr = _cache$serializeKey6[2];\n\n  config = Object.assign({}, defaultConfig, useContext(SWRConfigContext), config);\n\n  if (typeof fn === 'undefined') {\n    // use a global fetcher\n    fn = config.fetcher;\n  }\n\n  var initialData = cache.get(key) || config.initialData;\n  var initialError = cache.get(keyErr); // if a state is accessed (data, error or isValidating),\n  // we add the state to dependencies so if the state is\n  // updated in the future, we can trigger a rerender\n\n  var stateDependencies = useRef({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  var stateRef = useRef({\n    data: initialData,\n    error: initialError,\n    isValidating: false\n  });\n  var rerender = useState(null)[1];\n  var dispatch = useCallback(function (payload) {\n    var shouldUpdateState = false;\n\n    for (var k in payload) {\n      stateRef.current[k] = payload[k];\n\n      if (stateDependencies.current[k]) {\n        shouldUpdateState = true;\n      }\n    }\n\n    if (shouldUpdateState || config.suspense) {\n      rerender({});\n    }\n  }, []); // error ref inside revalidate (is last request errored?)\n\n  var unmountedRef = useRef(false);\n  var keyRef = useRef(key);\n  var boundMutate = useCallback(function (data, shouldRevalidate) {\n    return mutate(key, data, shouldRevalidate);\n  }, [key]); // start a revalidation\n\n  var revalidate = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var revalidateOpts,\n        loading,\n        shouldDeduping,\n        newData,\n        startAt,\n        newState,\n        retryCount,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            revalidateOpts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n\n            if (!(!key || !fn)) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", false);\n\n          case 3:\n            if (!unmountedRef.current) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", false);\n\n          case 5:\n            revalidateOpts = Object.assign({\n              dedupe: false\n            }, revalidateOpts);\n            loading = true;\n            shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && revalidateOpts.dedupe; // start fetching\n\n            _context2.prev = 8;\n            dispatch({\n              isValidating: true\n            });\n\n            if (!shouldDeduping) {\n              _context2.next = 17;\n              break;\n            }\n\n            // there's already an ongoing request,\n            // this one needs to be deduplicated.\n            startAt = CONCURRENT_PROMISES_TS[key];\n            _context2.next = 14;\n            return CONCURRENT_PROMISES[key];\n\n          case 14:\n            newData = _context2.sent;\n            _context2.next = 26;\n            break;\n\n          case 17:\n            // if not deduping the request (hard revalidate) but\n            // there're other ongoing request(s) at the same time,\n            // we need to ignore the other result(s) to avoid\n            // possible race conditions:\n            // req1------------------>res1\n            //      req2-------->res2\n            // in that case, the second response should not be overridden\n            // by the first one.\n            if (CONCURRENT_PROMISES[key]) {\n              // we can mark it as a mutation to ignore\n              // all requests which are fired before this one\n              MUTATION_TS[key] = Date.now() - 1;\n            } // if no cache being rendered currently (it shows a blank page),\n            // we trigger the loading slow event.\n\n\n            if (config.loadingTimeout && !cache.get(key)) {\n              setTimeout(function () {\n                if (loading) config.onLoadingSlow(key, config);\n              }, config.loadingTimeout);\n            }\n\n            if (fnArgs !== null) {\n              CONCURRENT_PROMISES[key] = fn.apply(void 0, _toConsumableArray(fnArgs));\n            } else {\n              CONCURRENT_PROMISES[key] = fn(key);\n            }\n\n            CONCURRENT_PROMISES_TS[key] = startAt = Date.now();\n            _context2.next = 23;\n            return CONCURRENT_PROMISES[key];\n\n          case 23:\n            newData = _context2.sent;\n            setTimeout(function () {\n              delete CONCURRENT_PROMISES[key];\n              delete CONCURRENT_PROMISES_TS[key];\n            }, config.dedupingInterval); // trigger the success event,\n            // only do this for the original request.\n\n            config.onSuccess(newData, key, config);\n\n          case 26:\n            if (!(MUTATION_TS[key] && startAt <= MUTATION_TS[key])) {\n              _context2.next = 29;\n              break;\n            }\n\n            dispatch({\n              isValidating: false\n            });\n            return _context2.abrupt(\"return\", false);\n\n          case 29:\n            cache.set(key, newData, false);\n            cache.set(keyErr, undefined, false); // new state for the reducer\n\n            newState = {\n              isValidating: false\n            };\n\n            if (typeof stateRef.current.error !== 'undefined') {\n              // we don't have an error\n              newState.error = undefined;\n            }\n\n            if (config.compare(stateRef.current.data, newData)) {// deep compare to avoid extra re-render\n              // do nothing\n            } else {\n              // data changed\n              newState.data = newData;\n            } // merge the new state\n\n\n            dispatch(newState);\n\n            if (!shouldDeduping) {\n              // also update other hooks\n              broadcastState(key, newData, undefined);\n            }\n\n            _context2.next = 46;\n            break;\n\n          case 38:\n            _context2.prev = 38;\n            _context2.t0 = _context2[\"catch\"](8);\n            delete CONCURRENT_PROMISES[key];\n            delete CONCURRENT_PROMISES_TS[key];\n            cache.set(keyErr, _context2.t0, false); // get a new error\n            // don't use deep equal for errors\n\n            if (stateRef.current.error !== _context2.t0) {\n              // we keep the stale data\n              dispatch({\n                isValidating: false,\n                error: _context2.t0\n              });\n\n              if (!shouldDeduping) {\n                // also broadcast to update other hooks\n                broadcastState(key, undefined, _context2.t0);\n              }\n            } // events and retry\n\n\n            config.onError(_context2.t0, key, config);\n\n            if (config.shouldRetryOnError) {\n              // when retrying, we always enable deduping\n              retryCount = (revalidateOpts.retryCount || 0) + 1;\n              config.onErrorRetry(_context2.t0, key, config, revalidate, Object.assign({\n                dedupe: true\n              }, revalidateOpts, {\n                retryCount: retryCount\n              }));\n            }\n\n          case 46:\n            loading = false;\n            return _context2.abrupt(\"return\", true);\n\n          case 48:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[8, 38]]);\n  })), [key]); // mounted (client side rendering)\n\n  useIsomorphicLayoutEffect(function () {\n    if (!key) return undefined; // after `key` updates, we need to mark it as mounted\n\n    unmountedRef.current = false; // after the component is mounted (hydrated),\n    // we need to update the data from the cache\n    // and trigger a revalidation\n\n    var currentHookData = stateRef.current.data;\n    var latestKeyedData = cache.get(key) || config.initialData; // update the state if the key changed (not the inital render) or cache updated\n\n    if (keyRef.current !== key || !config.compare(currentHookData, latestKeyedData)) {\n      dispatch({\n        data: latestKeyedData\n      });\n      keyRef.current = key;\n    } // revalidate with deduping\n\n\n    var softRevalidate = function softRevalidate() {\n      return revalidate({\n        dedupe: true\n      });\n    }; // trigger a revalidation\n\n\n    if (!config.initialData) {\n      if (typeof latestKeyedData !== 'undefined' && !IS_SERVER && window['requestIdleCallback']) {\n        // delay revalidate if there's cache\n        // to not block the rendering\n        window['requestIdleCallback'](softRevalidate);\n      } else {\n        softRevalidate();\n      }\n    } // whenever the window gets focused, revalidate\n\n\n    var onFocus;\n\n    if (config.revalidateOnFocus) {\n      // throttle: avoid being called twice from both listeners\n      // and tabs being switched quickly\n      onFocus = throttle(softRevalidate, config.focusThrottleInterval);\n\n      if (!FOCUS_REVALIDATORS[key]) {\n        FOCUS_REVALIDATORS[key] = [onFocus];\n      } else {\n        FOCUS_REVALIDATORS[key].push(onFocus);\n      }\n    } // register global cache update listener\n\n\n    var onUpdate = function onUpdate() {\n      var shouldRevalidate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var updatedData = arguments.length > 1 ? arguments[1] : undefined;\n      var updatedError = arguments.length > 2 ? arguments[2] : undefined;\n      var dedupe = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      // update hook state\n      var newState = {};\n      var needUpdate = false;\n\n      if (typeof updatedData !== 'undefined' && !config.compare(stateRef.current.data, updatedData)) {\n        newState.data = updatedData;\n        needUpdate = true;\n      } // always update error\n      // because it can be `undefined`\n\n\n      if (stateRef.current.error !== updatedError) {\n        newState.error = updatedError;\n        needUpdate = true;\n      }\n\n      if (needUpdate) {\n        dispatch(newState);\n      }\n\n      if (shouldRevalidate) {\n        if (dedupe) {\n          return softRevalidate();\n        } else {\n          return revalidate();\n        }\n      }\n\n      return false;\n    }; // add updater to listeners\n\n\n    if (!CACHE_REVALIDATORS[key]) {\n      CACHE_REVALIDATORS[key] = [onUpdate];\n    } else {\n      CACHE_REVALIDATORS[key].push(onUpdate);\n    } // set up reconnecting when the browser regains network connection\n\n\n    var reconnect = null;\n\n    if (!IS_SERVER && window.addEventListener && config.revalidateOnReconnect) {\n      window.addEventListener('online', reconnect = softRevalidate);\n    }\n\n    return function () {\n      // cleanup\n      dispatch = function dispatch() {\n        return null;\n      }; // mark it as unmounted\n\n\n      unmountedRef.current = true;\n\n      if (onFocus && FOCUS_REVALIDATORS[key]) {\n        var revalidators = FOCUS_REVALIDATORS[key];\n        var index = revalidators.indexOf(onFocus);\n\n        if (index >= 0) {\n          // 10x faster than splice\n          // https://jsperf.com/array-remove-by-index\n          revalidators[index] = revalidators[revalidators.length - 1];\n          revalidators.pop();\n        }\n      }\n\n      if (CACHE_REVALIDATORS[key]) {\n        var _revalidators = CACHE_REVALIDATORS[key];\n\n        var _index = _revalidators.indexOf(onUpdate);\n\n        if (_index >= 0) {\n          _revalidators[_index] = _revalidators[_revalidators.length - 1];\n\n          _revalidators.pop();\n        }\n      }\n\n      if (!IS_SERVER && window.removeEventListener && reconnect !== null) {\n        window.removeEventListener('online', reconnect);\n      }\n    };\n  }, [key, revalidate]); // set up polling\n\n  useIsomorphicLayoutEffect(function () {\n    var timer = null;\n\n    var tick = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!stateRef.current.error && (config.refreshWhenHidden || isDocumentVisible()) && (config.refreshWhenOffline || isOnline()))) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return revalidate({\n                  dedupe: true\n                });\n\n              case 3:\n                if (config.refreshInterval) {\n                  timer = setTimeout(tick, config.refreshInterval);\n                }\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function tick() {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    if (config.refreshInterval) {\n      timer = setTimeout(tick, config.refreshInterval);\n    }\n\n    return function () {\n      if (timer) clearTimeout(timer);\n    };\n  }, [config.refreshInterval, config.refreshWhenHidden, config.refreshWhenOffline, revalidate]); // suspense\n\n  if (config.suspense) {\n    if (IS_SERVER) throw new Error('Suspense on server side is not yet supported!'); // in suspense mode, we can't return empty state\n    // (it should be suspended)\n    // try to get data and error from cache\n\n    var latestData = cache.get(key);\n    var latestError = cache.get(keyErr);\n\n    if (typeof latestData === 'undefined' && typeof latestError === 'undefined') {\n      // need to start the request if it hasn't\n      if (!CONCURRENT_PROMISES[key]) {\n        // trigger revalidate immediately\n        // to get the promise\n        revalidate();\n      }\n\n      if (CONCURRENT_PROMISES[key] && typeof CONCURRENT_PROMISES[key].then === 'function') {\n        // if it is a promise\n        throw CONCURRENT_PROMISES[key];\n      } // it's a value, return it directly (override)\n\n\n      latestData = CONCURRENT_PROMISES[key];\n    }\n\n    if (typeof latestData === 'undefined' && latestError) {\n      // in suspense mode, throw error if there's no content\n      throw latestError;\n    } // return the latest data / error from cache\n    // in case `key` has changed\n\n\n    return {\n      error: latestError,\n      data: latestData,\n      revalidate: revalidate,\n      mutate: boundMutate,\n      isValidating: stateRef.current.isValidating\n    };\n  } // define returned state\n  // can be memorized since the state is a ref\n\n\n  return useMemo(function () {\n    var state = {\n      revalidate: revalidate,\n      mutate: boundMutate\n    };\n    Object.defineProperties(state, {\n      error: {\n        // `key` might be changed in the upcoming hook re-render,\n        // but the previous state will stay\n        // so we need to match the latest key and data (fallback to `initialData`)\n        get: function get() {\n          stateDependencies.current.error = true;\n          return stateRef.current.error;\n        }\n      },\n      data: {\n        get: function get() {\n          stateDependencies.current.data = true;\n          return stateRef.current.data;\n        }\n      },\n      isValidating: {\n        get: function get() {\n          stateDependencies.current.isValidating = true;\n          return stateRef.current.isValidating;\n        }\n      }\n    });\n    return state;\n  }, [revalidate]);\n}\n\nvar SWRConfig = SWRConfigContext.Provider;\nexport { trigger, mutate, SWRConfig };\nexport default useSWR;","map":{"version":3,"sources":["C:/Users/Jakith/JackPriyan.github.io/node_modules/swr/esm/use-swr.js"],"names":["useCallback","useContext","useEffect","useLayoutEffect","useState","useRef","useMemo","defaultConfig","CACHE_REVALIDATORS","CONCURRENT_PROMISES","CONCURRENT_PROMISES_TS","FOCUS_REVALIDATORS","MUTATION_TS","cache","isDocumentVisible","isOnline","throttle","SWRConfigContext","IS_SERVER","window","useIsomorphicLayoutEffect","trigger","_key","shouldRevalidate","serializeKey","key","keyErr","updaters","currentData","get","currentError","i","length","broadcastState","data","error","mutate","_data","Date","now","then","set","useSWR","fn","config","fnArgs","Object","assign","fetcher","initialData","initialError","stateDependencies","isValidating","stateRef","rerender","dispatch","payload","shouldUpdateState","k","current","suspense","unmountedRef","keyRef","boundMutate","revalidate","revalidateOpts","dedupe","loading","shouldDeduping","startAt","newData","loadingTimeout","setTimeout","onLoadingSlow","dedupingInterval","onSuccess","undefined","newState","compare","onError","shouldRetryOnError","retryCount","onErrorRetry","currentHookData","latestKeyedData","softRevalidate","onFocus","revalidateOnFocus","focusThrottleInterval","push","onUpdate","updatedData","updatedError","needUpdate","reconnect","addEventListener","revalidateOnReconnect","revalidators","index","indexOf","pop","removeEventListener","timer","tick","refreshWhenHidden","refreshWhenOffline","refreshInterval","clearTimeout","Error","latestData","latestError","state","defineProperties","SWRConfig","Provider"],"mappings":"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","sourcesContent":["import { useCallback, useContext, useEffect, useLayoutEffect, useState, useRef, useMemo } from 'react';\nimport defaultConfig, { CACHE_REVALIDATORS, CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, MUTATION_TS, cache } from './config';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport throttle from './libs/throttle';\nimport SWRConfigContext from './swr-config-context';\nconst IS_SERVER = typeof window === 'undefined';\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\nconst trigger = (_key, shouldRevalidate = true) => {\n    // we are ignoring the second argument which correspond to the arguments\n    // the fetcher will receive when key is an array\n    const [key, , keyErr] = cache.serializeKey(_key);\n    if (!key)\n        return;\n    const updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        const currentData = cache.get(key);\n        const currentError = cache.get(keyErr);\n        for (let i = 0; i < updaters.length; ++i) {\n            updaters[i](shouldRevalidate, currentData, currentError, i > 0);\n        }\n    }\n};\nconst broadcastState = (key, data, error) => {\n    const updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        for (let i = 0; i < updaters.length; ++i) {\n            updaters[i](false, data, error);\n        }\n    }\n};\nconst mutate = async (_key, _data, shouldRevalidate = true) => {\n    const [key] = cache.serializeKey(_key);\n    if (!key)\n        return;\n    // if there is no new data, call revalidate against the key\n    if (typeof _data === 'undefined')\n        return trigger(_key, shouldRevalidate);\n    // update timestamp\n    MUTATION_TS[key] = Date.now() - 1;\n    let data, error;\n    if (_data && typeof _data === 'function') {\n        // `_data` is a function, call it passing current cache value\n        try {\n            data = await _data(cache.get(key));\n        }\n        catch (err) {\n            error = err;\n        }\n    }\n    else if (_data && typeof _data.then === 'function') {\n        // `_data` is a promise\n        try {\n            data = await _data;\n        }\n        catch (err) {\n            error = err;\n        }\n    }\n    else {\n        data = _data;\n    }\n    if (typeof data !== 'undefined') {\n        // update cached data, avoid notifying from the cache\n        cache.set(key, data, false);\n    }\n    // update existing SWR Hooks' state\n    const updaters = CACHE_REVALIDATORS[key];\n    if (updaters) {\n        for (let i = 0; i < updaters.length; ++i) {\n            updaters[i](!!shouldRevalidate, data, error, i > 0);\n        }\n    }\n    // throw error or return data to be used by caller of mutate\n    if (error)\n        throw error;\n    return data;\n};\nfunction useSWR(...args) {\n    let _key, fn, config = {};\n    if (args.length >= 1) {\n        _key = args[0];\n    }\n    if (args.length > 2) {\n        fn = args[1];\n        config = args[2];\n    }\n    else {\n        if (typeof args[1] === 'function') {\n            fn = args[1];\n        }\n        else if (typeof args[1] === 'object') {\n            config = args[1];\n        }\n    }\n    // we assume `key` as the identifier of the request\n    // `key` can change but `fn` shouldn't\n    // (because `revalidate` only depends on `key`)\n    // `keyErr` is the cache key for error objects\n    const [key, fnArgs, keyErr] = cache.serializeKey(_key);\n    config = Object.assign({}, defaultConfig, useContext(SWRConfigContext), config);\n    if (typeof fn === 'undefined') {\n        // use a global fetcher\n        fn = config.fetcher;\n    }\n    const initialData = cache.get(key) || config.initialData;\n    const initialError = cache.get(keyErr);\n    // if a state is accessed (data, error or isValidating),\n    // we add the state to dependencies so if the state is\n    // updated in the future, we can trigger a rerender\n    const stateDependencies = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    const stateRef = useRef({\n        data: initialData,\n        error: initialError,\n        isValidating: false\n    });\n    const rerender = useState(null)[1];\n    let dispatch = useCallback(payload => {\n        let shouldUpdateState = false;\n        for (let k in payload) {\n            stateRef.current[k] = payload[k];\n            if (stateDependencies.current[k]) {\n                shouldUpdateState = true;\n            }\n        }\n        if (shouldUpdateState || config.suspense) {\n            rerender({});\n        }\n    }, []);\n    // error ref inside revalidate (is last request errored?)\n    const unmountedRef = useRef(false);\n    const keyRef = useRef(key);\n    const boundMutate = useCallback((data, shouldRevalidate) => {\n        return mutate(key, data, shouldRevalidate);\n    }, [key]);\n    // start a revalidation\n    const revalidate = useCallback(async (revalidateOpts = {}) => {\n        if (!key || !fn)\n            return false;\n        if (unmountedRef.current)\n            return false;\n        revalidateOpts = Object.assign({ dedupe: false }, revalidateOpts);\n        let loading = true;\n        let shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && revalidateOpts.dedupe;\n        // start fetching\n        try {\n            dispatch({\n                isValidating: true\n            });\n            let newData;\n            let startAt;\n            if (shouldDeduping) {\n                // there's already an ongoing request,\n                // this one needs to be deduplicated.\n                startAt = CONCURRENT_PROMISES_TS[key];\n                newData = await CONCURRENT_PROMISES[key];\n            }\n            else {\n                // if not deduping the request (hard revalidate) but\n                // there're other ongoing request(s) at the same time,\n                // we need to ignore the other result(s) to avoid\n                // possible race conditions:\n                // req1------------------>res1\n                //      req2-------->res2\n                // in that case, the second response should not be overridden\n                // by the first one.\n                if (CONCURRENT_PROMISES[key]) {\n                    // we can mark it as a mutation to ignore\n                    // all requests which are fired before this one\n                    MUTATION_TS[key] = Date.now() - 1;\n                }\n                // if no cache being rendered currently (it shows a blank page),\n                // we trigger the loading slow event.\n                if (config.loadingTimeout && !cache.get(key)) {\n                    setTimeout(() => {\n                        if (loading)\n                            config.onLoadingSlow(key, config);\n                    }, config.loadingTimeout);\n                }\n                if (fnArgs !== null) {\n                    CONCURRENT_PROMISES[key] = fn(...fnArgs);\n                }\n                else {\n                    CONCURRENT_PROMISES[key] = fn(key);\n                }\n                CONCURRENT_PROMISES_TS[key] = startAt = Date.now();\n                newData = await CONCURRENT_PROMISES[key];\n                setTimeout(() => {\n                    delete CONCURRENT_PROMISES[key];\n                    delete CONCURRENT_PROMISES_TS[key];\n                }, config.dedupingInterval);\n                // trigger the success event,\n                // only do this for the original request.\n                config.onSuccess(newData, key, config);\n            }\n            // if the revalidation happened earlier than the local mutation,\n            // we have to ignore the result because it could override.\n            // meanwhile, a new revalidation should be triggered by the mutation.\n            if (MUTATION_TS[key] && startAt <= MUTATION_TS[key]) {\n                dispatch({ isValidating: false });\n                return false;\n            }\n            cache.set(key, newData, false);\n            cache.set(keyErr, undefined, false);\n            // new state for the reducer\n            const newState = {\n                isValidating: false\n            };\n            if (typeof stateRef.current.error !== 'undefined') {\n                // we don't have an error\n                newState.error = undefined;\n            }\n            if (config.compare(stateRef.current.data, newData)) {\n                // deep compare to avoid extra re-render\n                // do nothing\n            }\n            else {\n                // data changed\n                newState.data = newData;\n            }\n            // merge the new state\n            dispatch(newState);\n            if (!shouldDeduping) {\n                // also update other hooks\n                broadcastState(key, newData, undefined);\n            }\n        }\n        catch (err) {\n            delete CONCURRENT_PROMISES[key];\n            delete CONCURRENT_PROMISES_TS[key];\n            cache.set(keyErr, err, false);\n            // get a new error\n            // don't use deep equal for errors\n            if (stateRef.current.error !== err) {\n                // we keep the stale data\n                dispatch({\n                    isValidating: false,\n                    error: err\n                });\n                if (!shouldDeduping) {\n                    // also broadcast to update other hooks\n                    broadcastState(key, undefined, err);\n                }\n            }\n            // events and retry\n            config.onError(err, key, config);\n            if (config.shouldRetryOnError) {\n                // when retrying, we always enable deduping\n                const retryCount = (revalidateOpts.retryCount || 0) + 1;\n                config.onErrorRetry(err, key, config, revalidate, Object.assign({ dedupe: true }, revalidateOpts, { retryCount }));\n            }\n        }\n        loading = false;\n        return true;\n    }, [key]);\n    // mounted (client side rendering)\n    useIsomorphicLayoutEffect(() => {\n        if (!key)\n            return undefined;\n        // after `key` updates, we need to mark it as mounted\n        unmountedRef.current = false;\n        // after the component is mounted (hydrated),\n        // we need to update the data from the cache\n        // and trigger a revalidation\n        const currentHookData = stateRef.current.data;\n        const latestKeyedData = cache.get(key) || config.initialData;\n        // update the state if the key changed (not the inital render) or cache updated\n        if (keyRef.current !== key ||\n            !config.compare(currentHookData, latestKeyedData)) {\n            dispatch({ data: latestKeyedData });\n            keyRef.current = key;\n        }\n        // revalidate with deduping\n        const softRevalidate = () => revalidate({ dedupe: true });\n        // trigger a revalidation\n        if (!config.initialData) {\n            if (typeof latestKeyedData !== 'undefined' &&\n                !IS_SERVER &&\n                window['requestIdleCallback']) {\n                // delay revalidate if there's cache\n                // to not block the rendering\n                window['requestIdleCallback'](softRevalidate);\n            }\n            else {\n                softRevalidate();\n            }\n        }\n        // whenever the window gets focused, revalidate\n        let onFocus;\n        if (config.revalidateOnFocus) {\n            // throttle: avoid being called twice from both listeners\n            // and tabs being switched quickly\n            onFocus = throttle(softRevalidate, config.focusThrottleInterval);\n            if (!FOCUS_REVALIDATORS[key]) {\n                FOCUS_REVALIDATORS[key] = [onFocus];\n            }\n            else {\n                FOCUS_REVALIDATORS[key].push(onFocus);\n            }\n        }\n        // register global cache update listener\n        const onUpdate = (shouldRevalidate = true, updatedData, updatedError, dedupe = true) => {\n            // update hook state\n            const newState = {};\n            let needUpdate = false;\n            if (typeof updatedData !== 'undefined' &&\n                !config.compare(stateRef.current.data, updatedData)) {\n                newState.data = updatedData;\n                needUpdate = true;\n            }\n            // always update error\n            // because it can be `undefined`\n            if (stateRef.current.error !== updatedError) {\n                newState.error = updatedError;\n                needUpdate = true;\n            }\n            if (needUpdate) {\n                dispatch(newState);\n            }\n            if (shouldRevalidate) {\n                if (dedupe) {\n                    return softRevalidate();\n                }\n                else {\n                    return revalidate();\n                }\n            }\n            return false;\n        };\n        // add updater to listeners\n        if (!CACHE_REVALIDATORS[key]) {\n            CACHE_REVALIDATORS[key] = [onUpdate];\n        }\n        else {\n            CACHE_REVALIDATORS[key].push(onUpdate);\n        }\n        // set up reconnecting when the browser regains network connection\n        let reconnect = null;\n        if (!IS_SERVER && window.addEventListener && config.revalidateOnReconnect) {\n            window.addEventListener('online', (reconnect = softRevalidate));\n        }\n        return () => {\n            // cleanup\n            dispatch = () => null;\n            // mark it as unmounted\n            unmountedRef.current = true;\n            if (onFocus && FOCUS_REVALIDATORS[key]) {\n                const revalidators = FOCUS_REVALIDATORS[key];\n                const index = revalidators.indexOf(onFocus);\n                if (index >= 0) {\n                    // 10x faster than splice\n                    // https://jsperf.com/array-remove-by-index\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (CACHE_REVALIDATORS[key]) {\n                const revalidators = CACHE_REVALIDATORS[key];\n                const index = revalidators.indexOf(onUpdate);\n                if (index >= 0) {\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (!IS_SERVER && window.removeEventListener && reconnect !== null) {\n                window.removeEventListener('online', reconnect);\n            }\n        };\n    }, [key, revalidate]);\n    // set up polling\n    useIsomorphicLayoutEffect(() => {\n        let timer = null;\n        const tick = async () => {\n            if (!stateRef.current.error &&\n                (config.refreshWhenHidden || isDocumentVisible()) &&\n                (config.refreshWhenOffline || isOnline())) {\n                // only revalidate when the page is visible\n                // if API request errored, we stop polling in this round\n                // and let the error retry function handle it\n                await revalidate({ dedupe: true });\n            }\n            if (config.refreshInterval) {\n                timer = setTimeout(tick, config.refreshInterval);\n            }\n        };\n        if (config.refreshInterval) {\n            timer = setTimeout(tick, config.refreshInterval);\n        }\n        return () => {\n            if (timer)\n                clearTimeout(timer);\n        };\n    }, [\n        config.refreshInterval,\n        config.refreshWhenHidden,\n        config.refreshWhenOffline,\n        revalidate\n    ]);\n    // suspense\n    if (config.suspense) {\n        if (IS_SERVER)\n            throw new Error('Suspense on server side is not yet supported!');\n        // in suspense mode, we can't return empty state\n        // (it should be suspended)\n        // try to get data and error from cache\n        let latestData = cache.get(key);\n        let latestError = cache.get(keyErr);\n        if (typeof latestData === 'undefined' &&\n            typeof latestError === 'undefined') {\n            // need to start the request if it hasn't\n            if (!CONCURRENT_PROMISES[key]) {\n                // trigger revalidate immediately\n                // to get the promise\n                revalidate();\n            }\n            if (CONCURRENT_PROMISES[key] &&\n                typeof CONCURRENT_PROMISES[key].then === 'function') {\n                // if it is a promise\n                throw CONCURRENT_PROMISES[key];\n            }\n            // it's a value, return it directly (override)\n            latestData = CONCURRENT_PROMISES[key];\n        }\n        if (typeof latestData === 'undefined' && latestError) {\n            // in suspense mode, throw error if there's no content\n            throw latestError;\n        }\n        // return the latest data / error from cache\n        // in case `key` has changed\n        return {\n            error: latestError,\n            data: latestData,\n            revalidate,\n            mutate: boundMutate,\n            isValidating: stateRef.current.isValidating\n        };\n    }\n    // define returned state\n    // can be memorized since the state is a ref\n    return useMemo(() => {\n        const state = { revalidate, mutate: boundMutate };\n        Object.defineProperties(state, {\n            error: {\n                // `key` might be changed in the upcoming hook re-render,\n                // but the previous state will stay\n                // so we need to match the latest key and data (fallback to `initialData`)\n                get: function () {\n                    stateDependencies.current.error = true;\n                    return stateRef.current.error;\n                }\n            },\n            data: {\n                get: function () {\n                    stateDependencies.current.data = true;\n                    return stateRef.current.data;\n                }\n            },\n            isValidating: {\n                get: function () {\n                    stateDependencies.current.isValidating = true;\n                    return stateRef.current.isValidating;\n                }\n            }\n        });\n        return state;\n    }, [revalidate]);\n}\nconst SWRConfig = SWRConfigContext.Provider;\nexport { trigger, mutate, SWRConfig };\nexport default useSWR;\n"]},"metadata":{},"sourceType":"module"}