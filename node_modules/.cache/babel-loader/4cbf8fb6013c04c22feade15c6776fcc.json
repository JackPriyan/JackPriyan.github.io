{"ast":null,"code":"import { parseRootMargin, shallowCompare } from './utils';\nexport var observerElementsMap = new Map();\nexport function getPooled(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var root = options.root || null;\n  var rootMargin = parseRootMargin(options.rootMargin);\n  var threshold = Array.isArray(options.threshold) ? options.threshold : [options.threshold != null ? options.threshold : 0];\n  var observers = observerElementsMap.keys();\n  var observer;\n\n  while (observer = observers.next().value) {\n    var unmatched = root !== observer.root || rootMargin !== observer.rootMargin || shallowCompare(threshold, observer.thresholds);\n\n    if (!unmatched) {\n      return observer;\n    }\n  }\n\n  return null;\n}\nexport function findObserverElement(observer, entry) {\n  var elements = observerElementsMap.get(observer);\n\n  if (elements) {\n    var values = elements.values();\n    var element;\n\n    while (element = values.next().value) {\n      if (element.target === entry.target) {\n        return element;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * The Intersection Observer API callback that is called whenever one element\n * – namely the target – intersects either the device viewport or a specified element.\n * Also will get called whenever the visibility of the target element changes and\n * crosses desired amounts of intersection with the root.\n * @param {array} changes\n * @param {IntersectionObserver} observer\n */\n\nexport function callback(changes, observer) {\n  for (var i = 0; i < changes.length; i++) {\n    var element = findObserverElement(observer, changes[i]);\n\n    if (element) {\n      element.handleChange(changes[i]);\n    }\n  }\n}\nexport function createObserver(options) {\n  return getPooled(options) || new IntersectionObserver(callback, options);\n}\nexport function observeElement(element) {\n  if (!observerElementsMap.has(element.observer)) {\n    observerElementsMap.set(element.observer, new Set());\n  }\n\n  observerElementsMap.get(element.observer).add(element);\n  element.observer.observe(element.target);\n}\nexport function unobserveElement(element, target) {\n  if (observerElementsMap.has(element.observer)) {\n    var targets = observerElementsMap.get(element.observer);\n\n    if (targets[\"delete\"](element)) {\n      if (targets.size > 0) {\n        element.observer.unobserve(target);\n      } else {\n        element.observer.disconnect();\n        observerElementsMap[\"delete\"](element.observer);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Jakith/JackPriyan.github.io/node_modules/@researchgate/react-intersection-observer/lib/es/observer.js"],"names":["parseRootMargin","shallowCompare","observerElementsMap","Map","getPooled","options","root","rootMargin","threshold","Array","isArray","observers","keys","observer","next","value","unmatched","thresholds","findObserverElement","entry","elements","get","values","element","target","callback","changes","i","length","handleChange","createObserver","IntersectionObserver","observeElement","has","set","Set","add","observe","unobserveElement","targets","size","unobserve","disconnect"],"mappings":"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","sourcesContent":["import { parseRootMargin, shallowCompare } from './utils';\nexport var observerElementsMap = new Map();\nexport function getPooled(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var root = options.root || null;\n  var rootMargin = parseRootMargin(options.rootMargin);\n  var threshold = Array.isArray(options.threshold) ? options.threshold : [options.threshold != null ? options.threshold : 0];\n  var observers = observerElementsMap.keys();\n  var observer;\n\n  while (observer = observers.next().value) {\n    var unmatched = root !== observer.root || rootMargin !== observer.rootMargin || shallowCompare(threshold, observer.thresholds);\n\n    if (!unmatched) {\n      return observer;\n    }\n  }\n\n  return null;\n}\nexport function findObserverElement(observer, entry) {\n  var elements = observerElementsMap.get(observer);\n\n  if (elements) {\n    var values = elements.values();\n    var element;\n\n    while (element = values.next().value) {\n      if (element.target === entry.target) {\n        return element;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * The Intersection Observer API callback that is called whenever one element\n * – namely the target – intersects either the device viewport or a specified element.\n * Also will get called whenever the visibility of the target element changes and\n * crosses desired amounts of intersection with the root.\n * @param {array} changes\n * @param {IntersectionObserver} observer\n */\n\nexport function callback(changes, observer) {\n  for (var i = 0; i < changes.length; i++) {\n    var element = findObserverElement(observer, changes[i]);\n\n    if (element) {\n      element.handleChange(changes[i]);\n    }\n  }\n}\nexport function createObserver(options) {\n  return getPooled(options) || new IntersectionObserver(callback, options);\n}\nexport function observeElement(element) {\n  if (!observerElementsMap.has(element.observer)) {\n    observerElementsMap.set(element.observer, new Set());\n  }\n\n  observerElementsMap.get(element.observer).add(element);\n  element.observer.observe(element.target);\n}\nexport function unobserveElement(element, target) {\n  if (observerElementsMap.has(element.observer)) {\n    var targets = observerElementsMap.get(element.observer);\n\n    if (targets[\"delete\"](element)) {\n      if (targets.size > 0) {\n        element.observer.unobserve(target);\n      } else {\n        element.observer.disconnect();\n        observerElementsMap[\"delete\"](element.observer);\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}