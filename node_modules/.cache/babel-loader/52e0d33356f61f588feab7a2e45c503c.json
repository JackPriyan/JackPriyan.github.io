{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\Jakith\\\\JackPriyan.github.io\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"C:\\\\Users\\\\Jakith\\\\JackPriyan.github.io\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\n\nvar pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset) {\n  var deps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var pageCountKey = \"_swr_page_count_\" + pageKey;\n  var pageOffsetKey = \"_swr_page_offset_\" + pageKey;\n\n  var _useState = useState(cache.get(pageCountKey) || 1),\n      _useState2 = _slicedToArray(_useState, 2),\n      pageCount = _useState2[0],\n      setPageCount = _useState2[1];\n\n  var _useState3 = useState(cache.get(pageOffsetKey) || [null]),\n      _useState4 = _slicedToArray(_useState3, 2),\n      pageOffsets = _useState4[0],\n      setPageOffsets = _useState4[1];\n\n  var _useState5 = useState([]),\n      _useState6 = _slicedToArray(_useState5, 2),\n      pageSWRs = _useState6[0],\n      setPageSWRs = _useState6[1];\n\n  var pageFnRef = useRef(pageFn);\n  var emptyPageRef = useRef(false); // Page component (wraps `pageFn`)\n  // for performance reason we need to memorize it\n\n  var Page = useCallback(function (props) {\n    // render the page component\n    var dataList = pageFnRef.current(props); // if dataList is [], we can assume this page is empty\n    // TODO: this API is not stable\n\n    if (dataList && !dataList.length) {\n      emptyPageRef.current = true;\n    } else {\n      emptyPageRef.current = false;\n    }\n\n    return dataList;\n  }, []); // Doesn't have a next page\n\n  var isReachingEnd = pageOffsets[pageCount] === null;\n  var isLoadingMore = pageCount === pageOffsets.length;\n  var isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n  var loadMore = useCallback(function () {\n    if (isLoadingMore || isReachingEnd) return;\n    setPageCount(function (c) {\n      cache.set(pageCountKey, c + 1);\n      return c + 1;\n    });\n  }, [isLoadingMore || isReachingEnd]);\n\n  var _pageFn = useCallback(pageFn, deps);\n\n  pageFnRef.current = _pageFn;\n  var pages = useMemo(function () {\n    var getWithSWR = function getWithSWR(id) {\n      return function (swr) {\n        if (!pageSWRs[id] || pageSWRs[id].data !== swr.data || pageSWRs[id].error !== swr.error || pageSWRs[id].revalidate !== swr.revalidate) {\n          // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n          setTimeout(function () {\n            setPageSWRs(function (swrs) {\n              var _swrs = _toConsumableArray(swrs);\n\n              _swrs[id] = {\n                data: swr.data,\n                error: swr.error,\n                revalidate: swr.revalidate,\n                isValidating: swr.isValidating,\n                mutate: swr.mutate\n              };\n              return _swrs;\n            });\n\n            if (typeof swr.data !== 'undefined') {\n              // set next page's offset\n              var newPageOffset = SWRToOffset(swr, id);\n\n              if (pageOffsets[id + 1] !== newPageOffset) {\n                setPageOffsets(function (arr) {\n                  var _arr = _toConsumableArray(arr);\n\n                  _arr[id + 1] = newPageOffset;\n                  cache.set(pageOffsetKey, _arr);\n                  return _arr;\n                });\n              }\n            }\n          });\n        }\n\n        return swr;\n      };\n    }; // render each page\n\n\n    var p = [];\n\n    if (!pageCacheMap.has(pageKey)) {\n      pageCacheMap.set(pageKey, []);\n    }\n\n    var pageCache = pageCacheMap.get(pageKey);\n\n    for (var i = 0; i < pageCount; ++i) {\n      if (!pageCache[i] || pageCache[i].offset !== pageOffsets[i] || pageCache[i].pageFn !== _pageFn) {\n        // when props change or at init\n        // render the page and cache it\n        pageCache[i] = {\n          component: React.createElement(Page, {\n            key: \"page-\".concat(pageOffsets[i], \"-\").concat(i),\n            offset: pageOffsets[i],\n            withSWR: getWithSWR(i)\n          }),\n          pageFn: _pageFn,\n          offset: pageOffsets[i]\n        };\n      }\n\n      p.push(pageCache[i].component);\n    }\n\n    return p;\n  }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n  return {\n    pages: pages,\n    pageCount: pageCount,\n    pageSWRs: pageSWRs,\n    isLoadingMore: isLoadingMore,\n    isReachingEnd: isReachingEnd,\n    isEmpty: isEmpty,\n    loadMore: loadMore\n  };\n}","map":{"version":3,"sources":["C:/Users/Jakith/JackPriyan.github.io/node_modules/swr/esm/use-swr-pages.js"],"names":["React","useCallback","useMemo","useState","useRef","cache","pageCacheMap","Map","useSWRPages","pageKey","pageFn","SWRToOffset","deps","pageCountKey","pageOffsetKey","get","pageCount","setPageCount","pageOffsets","setPageOffsets","pageSWRs","setPageSWRs","pageFnRef","emptyPageRef","Page","props","dataList","current","length","isReachingEnd","isLoadingMore","isEmpty","loadMore","c","set","_pageFn","pages","getWithSWR","id","swr","data","error","revalidate","setTimeout","swrs","_swrs","isValidating","mutate","newPageOffset","arr","_arr","p","has","pageCache","i","offset","component","createElement","key","withSWR","push"],"mappings":"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","sourcesContent":["import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nconst pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n    const pageCountKey = `_swr_page_count_` + pageKey;\n    const pageOffsetKey = `_swr_page_offset_` + pageKey;\n    const [pageCount, setPageCount] = useState(cache.get(pageCountKey) || 1);\n    const [pageOffsets, setPageOffsets] = useState(cache.get(pageOffsetKey) || [null]);\n    const [pageSWRs, setPageSWRs] = useState([]);\n    const pageFnRef = useRef(pageFn);\n    const emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    const Page = useCallback(props => {\n        // render the page component\n        const dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    const isReachingEnd = pageOffsets[pageCount] === null;\n    const isLoadingMore = pageCount === pageOffsets.length;\n    const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    const loadMore = useCallback(() => {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(c => {\n            cache.set(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    const _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    const pages = useMemo(() => {\n        const getWithSWR = id => swr => {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n                setTimeout(() => {\n                    setPageSWRs(swrs => {\n                        const _swrs = [...swrs];\n                        _swrs[id] = {\n                            data: swr.data,\n                            error: swr.error,\n                            revalidate: swr.revalidate,\n                            isValidating: swr.isValidating,\n                            mutate: swr.mutate\n                        };\n                        return _swrs;\n                    });\n                    if (typeof swr.data !== 'undefined') {\n                        // set next page's offset\n                        const newPageOffset = SWRToOffset(swr, id);\n                        if (pageOffsets[id + 1] !== newPageOffset) {\n                            setPageOffsets(arr => {\n                                const _arr = [...arr];\n                                _arr[id + 1] = newPageOffset;\n                                cache.set(pageOffsetKey, _arr);\n                                return _arr;\n                            });\n                        }\n                    }\n                });\n            }\n            return swr;\n        };\n        // render each page\n        const p = [];\n        if (!pageCacheMap.has(pageKey)) {\n            pageCacheMap.set(pageKey, []);\n        }\n        const pageCache = pageCacheMap.get(pageKey);\n        for (let i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: `page-${pageOffsets[i]}-${i}`, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages,\n        pageCount,\n        pageSWRs,\n        isLoadingMore,\n        isReachingEnd,\n        isEmpty,\n        loadMore\n    };\n}\n"]},"metadata":{},"sourceType":"module"}